## 堆和栈的区别

### 申请方式不同：

  - 栈（英文名称是 stack ）是系统自动分配空间的，例如我们定义一个 `char a` ，系统会自动在栈上为其开辟空间

  - 堆（英文名称是 heap ）则是程序员根据需要自己申请的空间，例如 `malloc(10)`，开辟十个字节的空间

### 回收机制：

  - 由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问

  - 堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露

### 其他的一些区别

#### 申请后系统的响应

- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出

- 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序

  - 对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间

  - 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中

  - 也就是说堆会在申请后还要做一些后续的工作，这就会引出申请效率的问题

#### 申请效率的比较

- 栈：由系统自动分配，速度较快，但程序员是无法控制的

- 堆：是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便

#### 申请大小的限制

- 栈：在 Windows 下,栈是向低地址扩展的数据结构，是一块连续的内存的区域

  - 这句话的意思是：栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 2M（也有的说是 1M ，总之是一个编译时就确定的常数）
  
  - 如果申请的空间超过栈的剩余空间时，将提示overflow
  
  - 因此，能从栈获得的空间较小

- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域

  - 这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址
  
  - 堆的大小受限于计算机系统中有效的虚拟内存
  
  - 由此可见，堆获得的空间比较灵活，也比较大

#### 堆和栈中的存储内容

> 由于栈的大小有限，所以用子函数还是有物理意义的，而不仅仅是逻辑意义

- 栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量

  - 注意：静态变量是不入栈的

  - 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行

- 堆：一般是在堆的头部用一个字节存放堆的大小

  - 堆中的具体内容有程序员安排

#### 存取效率的比较

```c
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
```

- `aaaaaaaaaaa` 是在运行时刻赋值的；放在栈中

- `bbbbbbbbbbb` 是在编译时就确定的；放在堆中

> 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快

```c
#include
void main()
{
 char a = 1;
 char c[] = "1234567890";
 char *p ="1234567890";
 a = c[1];
 a = p[1];
 return;
}
```

```
**对应的汇编代码 **
**10: a = c[1]; **
**00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] **
**0040106A 88 4D FC mov byte ptr [ebp-4],cl **
**11: a = p[1]; **
**0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] **
**00401070 8A 42 01 mov al,byte ptr [edx+1] **
**00401073 88 45 FC mov byte ptr [ebp-4],al**
```

### 关于堆和栈区别的比喻

- 使用栈：就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小

- 使用堆：就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大
